import * as jsonpathPlus from 'jsonpath-plus';
import { extractWithJsonPathSafe } from './json';

/* Generated by @n1k1t/unit-generator */
it('should return status OK for a simple extraction', () => {
  const data = { a: 1 };
  const result = extractWithJsonPathSafe({ path: '$.a', json: data });
  expect(result.status).toEqual('OK');
});

/* Generated by @n1k1t/unit-generator */
it('should extract the correct simple value', () => {
  const data = { a: 1 };
  const result = extractWithJsonPathSafe({ path: '$.a', json: data });
  expect(result.results?.[0].value).toEqual(1);
});

/* Generated by @n1k1t/unit-generator */
it('should return one result for a simple extraction', () => {
  const data = { a: 1 };
  const result = extractWithJsonPathSafe({ path: '$.a', json: data });
  expect(result.results).toHaveLength(1);
});

/* Generated by @n1k1t/unit-generator */
it('should return status OK for multiple extractions', () => {
  const data = { a: [{ b: 1 }, { b: 2 }] };
  const result = extractWithJsonPathSafe({ path: '$.a[*].b', json: data });
  expect(result.status).toEqual('OK');
});

/* Generated by @n1k1t/unit-generator */
it('should return two results for multiple extractions', () => {
  const data = { a: [{ b: 1 }, { b: 2 }] };
  const result = extractWithJsonPathSafe({ path: '$.a[*].b', json: data });
  expect(result.results).toHaveLength(2);
});

/* Generated by @n1k1t/unit-generator */
it('should extract the first correct value in multiple extractions', () => {
  const data = { a: [{ b: 1 }, { b: 2 }] };
  const result = extractWithJsonPathSafe({ path: '$.a[*].b', json: data });
  expect(result.results?.[0].value).toEqual(1);
});

/* Generated by @n1k1t/unit-generator */
it('should extract the second correct value in multiple extractions', () => {
  const data = { a: [{ b: 1 }, { b: 2 }] };
  const result = extractWithJsonPathSafe({ path: '$.a[*].b', json: data });
  expect(result.results?.[1].value).toEqual(2);
});

/* Generated by @n1k1t/unit-generator */
it('should return status OK for a nested extraction', () => {
  const data = { a: { b: { c: 3 } } };
  const result = extractWithJsonPathSafe({ path: '$.a.b.c', json: data });
  expect(result.status).toEqual('OK');
});

/* Generated by @n1k1t/unit-generator */
it('should extract the correct nested value', () => {
  const data = { a: { b: { c: 3 } } };
  const result = extractWithJsonPathSafe({ path: '$.a.b.c', json: data });
  expect(result.results?.[0].value).toEqual(3);
});

/* Generated by @n1k1t/unit-generator */
it('should return status OK for a non-existent path', () => {
  const data = { a: 1 };
  const result = extractWithJsonPathSafe({ path: '$.b', json: data });
  expect(result.status).toEqual('OK');
});

/* Generated by @n1k1t/unit-generator */
it('should return an empty array for a non-existent path', () => {
  const data = { a: 1 };
  const result = extractWithJsonPathSafe({ path: '$.b', json: data });
  expect(result.results).toHaveLength(0);
});

/* Generated by @n1k1t/unit-generator */
it('should return an ERROR status when JSONPath throws a non-Error object', () => {
  const mockError = 'Something went wrong!';
  const jsonPathSpy = jest.spyOn(jsonpathPlus, 'JSONPath');
  jsonPathSpy.mockImplementation(() => { throw mockError; });

  const result = extractWithJsonPathSafe({ path: '$', json: {} });

  expect(result.status).toBe('ERROR');

  jsonPathSpy.mockRestore();
});

/* Generated by @n1k1t/unit-generator */
it('should return an error that is an instance of Error when JSONPath throws a non-Error object', () => {
  const mockError = 'Something went wrong!';
  const jsonPathSpy = jest.spyOn(jsonpathPlus, 'JSONPath');
  jsonPathSpy.mockImplementation(() => { throw mockError; });

  const result = extractWithJsonPathSafe({ path: '$', json: {} });

  expect(result.error).toBeInstanceOf(Error);

  jsonPathSpy.mockRestore();
});

/* Generated by @n1k1t/unit-generator */
it('should return an error with message "Unknown" when JSONPath throws a non-Error object', () => {
  const mockError = 'Something went wrong!';
  const jsonPathSpy = jest.spyOn(jsonpathPlus, 'JSONPath');
  jsonPathSpy.mockImplementation(() => { throw mockError; });

  const result = extractWithJsonPathSafe({ path: '$', json: {} });

  expect(result.error?.message).toBe('Unknown');

  jsonPathSpy.mockRestore();
});

/* Generated by @n1k1t/unit-generator */
it('should return status ERROR and an Error object when JSONPath throws an Error', () => {
  const mockError = new Error('Test error');
  jest.spyOn(jsonpathPlus, 'JSONPath').mockImplementation(() => {
    throw mockError;
  });

  const result = extractWithJsonPathSafe({ path: '$.some.path', json: {} });

  expect(result.status).toBe('ERROR');
  expect(result.error).toBe(mockError);
});

/* Generated by @n1k1t/unit-generator */
it('should return status ERROR and a new Error object when JSONPath throws a non-Error object', () => {
  const mockNonError = 'Something went wrong';
  jest.spyOn(jsonpathPlus, 'JSONPath').mockImplementation(() => {
    throw mockNonError;
  });

  const result = extractWithJsonPathSafe({ path: '$.some.path', json: {} });

  expect(result.status).toBe('ERROR');
  expect(result.error).toBeInstanceOf(Error);
  expect(result.error?.message).toBe('Unknown');
});
