import { Observable } from 'rxjs';
import { RxConverter } from './rx';

/* Generated by @n1k1t/unit-generator */
it('RxConverter.build should create an instance of RxConverter', () => {
  const observable = new Observable<number>();
  const converter = RxConverter.build(observable);
  expect(converter).toBeInstanceOf(RxConverter);
});

/* Generated by @n1k1t/unit-generator */
it('RxConverter.build should set the source observable', () => {
  const observable = new Observable<number>();
  const converter = RxConverter.build(observable);
  expect(converter.source).toBe(observable);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should yield the first value from the observable', async () => {
  const values = [1, 2, 3];
  const observable = new Observable<number>(subscriber => {
    values.forEach(v => subscriber.next(v));
    subscriber.complete();
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  const result = await iterator[Symbol.asyncIterator]().next();
  expect(result.value).toEqual(1);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should yield the second value from the observable', async () => {
  const values = [1, 2, 3];
  const observable = new Observable<number>(subscriber => {
    values.forEach(v => subscriber.next(v));
    subscriber.complete();
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  await iterator[Symbol.asyncIterator]().next(); // Consume 1
  const result = await iterator[Symbol.asyncIterator]().next();
  expect(result.value).toEqual(2);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should mark done as true when observable completes immediately', async () => {
  const observable = new Observable<number>(subscriber => {
    subscriber.complete();
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  const result = await iterator[Symbol.asyncIterator]().next();
  expect(result.done).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should throw an error if the observable errors immediately', async () => {
  const errorMessage = 'Test Error';
  const observable = new Observable<number>(subscriber => {
    subscriber.error(new Error(errorMessage));
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  await expect(iterator[Symbol.asyncIterator]().next()).rejects.toThrow(errorMessage);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should handle observable emitting values asynchronously', async () => {
  const observable = new Observable<number>(subscriber => {
    setTimeout(() => {
      subscriber.next(10);
      subscriber.complete();
    }, 10);
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  const result = await iterator[Symbol.asyncIterator]().next();
  expect(result.value).toEqual(10);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should mark done as true after asynchronous values and completion', async () => {
  const observable = new Observable<number>(subscriber => {
    setTimeout(() => {
      subscriber.next(10);
    }, 10);
    setTimeout(() => {
      subscriber.complete();
    }, 20);
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  await iterator[Symbol.asyncIterator]().next(); // Consume 10
  const result = await iterator[Symbol.asyncIterator]().next();
  expect(result.done).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should throw the first error if multiple errors occur', async () => {
  const errorMessage1 = 'Error 1';
  const observable = new Observable<number>(subscriber => {
    subscriber.error(new Error(errorMessage1));
    subscriber.error(new Error('Error 2')); // This error will be buffered but not thrown until the first is cleared.
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  await expect(iterator[Symbol.asyncIterator]().next()).rejects.toThrow(errorMessage1);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should return done: true for an observable that completes after some delay', async () => {
  const observable = new Observable<number>(subscriber => {
    setTimeout(() => {
      subscriber.complete();
    }, 10);
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  const result = await iterator[Symbol.asyncIterator]().next();
  expect(result.done).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('iterate should throw an error if observable errors after some delay', async () => {
  const errorMessage = 'Delayed Error';
  const observable = new Observable<number>(subscriber => {
    setTimeout(() => {
      subscriber.error(new Error(errorMessage));
    }, 10);
  });
  const converter = new RxConverter(observable);
  const iterator = converter.iterate();
  await expect(iterator[Symbol.asyncIterator]().next()).rejects.toThrow(errorMessage);
})
