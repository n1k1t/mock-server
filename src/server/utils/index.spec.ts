import { it, expect } from '@jest/globals';
import { Type } from '@n1k1t/typebox';
import { extractValidationMetaContext, validate, UseValidation } from './index';

/* Generated by @n1k1t/unit-generator */
it('extractValidationMetaContext should return null if no context is set', () => {
  class TestClass {}
  const context = extractValidationMetaContext(TestClass);
  expect(context).toBeNull();
});

/* Generated by @n1k1t/unit-generator */
it('UseValidation should create a validation context on the constructor if none exists', () => {
  const stringSchema = Type.String();
  class TestClass {
    @UseValidation(stringSchema)
    public name!: string;
  }
  const context = extractValidationMetaContext(TestClass);
  expect(context).not.toBeNull();
});

/* Generated by @n1k1t/unit-generator */
it('UseValidation should add the decorated property to the context properties set', () => {
  const stringSchema = Type.String();
  class TestClass {
    @UseValidation(stringSchema)
    public name!: string;
  }
  const context = extractValidationMetaContext(TestClass);
  expect(context?.properties.has('name')).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('UseValidation should update the schema with the new property', () => {
  const stringSchema = Type.String();
  class TestClass {
    @UseValidation(stringSchema)
    public name!: string;
  }
  const context = extractValidationMetaContext(TestClass);
  const expectedSchema = Type.Object({ name: stringSchema });
  expect(context?.schema).toEqual(expectedSchema);
});

/* Generated by @n1k1t/unit-generator */
it('UseValidation should add all decorated properties to the context properties set when multiple decorators are used', () => {
  const stringSchema = Type.String();
  const numberSchema = Type.Number();
  class TestClass {
    @UseValidation(stringSchema)
    public name!: string;

    @UseValidation(numberSchema)
    public age!: number;
  }
  const context = extractValidationMetaContext(TestClass);
  expect(context?.properties.has('name')).toBe(true);
  expect(context?.properties.has('age')).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('UseValidation should update the schema with all decorated properties when multiple decorators are used', () => {
  const stringSchema = Type.String();
  const numberSchema = Type.Number();
  class TestClass {
    @UseValidation(stringSchema)
    public name!: string;

    @UseValidation(numberSchema)
    public age!: number;
  }
  const context = extractValidationMetaContext(TestClass);
  expect(context?.schema.properties).toEqual({ name: stringSchema, age: numberSchema });
});

/* Generated by @n1k1t/unit-generator */
it('validate should return an empty array for a valid instance', () => {
  const stringSchema = Type.String();
  class TestClass {
    @UseValidation(stringSchema)
    public name: string;

    constructor(name: string) {
      this.name = name;
    }
  }
  const instance = new TestClass('John Doe');
  const errors = validate(instance);
  expect(errors).toEqual([]);
});

/* Generated by @n1k1t/unit-generator */
it('validate should return errors for an invalid instance', () => {
  const stringSchema = Type.String();
  class TestClass {
    @UseValidation(stringSchema)
    public name: string;

    constructor(name: any) {
      this.name = name;
    }
  }
  const instance = new TestClass(123);
  const errors = validate(instance);
  expect(errors.length).toBeGreaterThan(0);
  expect(errors[0].path).toBe('/name');
});

/* Generated by @n1k1t/unit-generator */
it('validate should return an empty array if no validation context exists for the constructor', () => {
  class TestClass {
    public name: string = 'test';
  }
  const instance = new TestClass();
  const errors = validate(instance);
  expect(errors).toEqual([]);
});
