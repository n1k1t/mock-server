import { RxConverter } from '../utils';
import { it, expect, jest } from '@jest/globals';
import { Logger } from '../../logger';
import { AnalyticsService } from './analytics.service';
import { TFunction } from '../../../types';

// Test generated using Keploy
test("calculateRedisUsage_noRedisConfig_returnsZeroUsage", async () => {
  const mockServer = { databases: { redis: null } };
  const analyticsService = new AnalyticsService(<any>mockServer);

  const result = await analyticsService.calculateRedisUsage();

  expect(result).toEqual({ count: 0, bytes: 0 });
});

// Test generated using Keploy
test("calculateRedisUsage_errorDuringScan_rejectsWithError", async () => {
  const mockStream = {
    once: jest.fn((event, handler: TFunction) => {
      if (event === 'error') handler(new Error('Scan Error'));
    }),
    on: jest.fn(),
    pause: jest.fn(),
    resume: jest.fn(),
    close: jest.fn(),
  };
  const mockServer = {
    databases: {
      redis: {
        scanStream: jest.fn(() => mockStream),
        options: { keyPrefix: '' }
      }
    }
  };
  const analyticsService = new AnalyticsService(<any>mockServer);

  await expect(analyticsService.calculateRedisUsage()).rejects.toThrow('Scan Error');
  expect(mockStream.close).toHaveBeenCalled();
});

/* Generated by @n1k1t/unit-generator */
it('should return an empty observable if redis is not available when calling iterateRedisKeys', (done) => {
  const mockServer = {
    databases: {
      redis: undefined,
    },
  };
  const service = new AnalyticsService(mockServer as any);

  service.iterateRedisKeys().subscribe({
    next: () => done(new Error('Should not emit any value')),
    complete: () => {
      expect(true).toBe(true);
      done();
    },
    error: (err) => done(err),
  });
});

/* Generated by @n1k1t/unit-generator */
it('should return an empty observable when redis is not available for iterateRedisKeys', (done) => {
  const mockLogger = {
    error: jest.fn(),
  };
  const loggerSpy = jest.spyOn(Logger, 'build').mockReturnValue(mockLogger as any);

  const mockServer = {
    databases: {
      redis: null,
    },
  };
  const service = new AnalyticsService(mockServer as any);
  let emitted = false;

  service.iterateRedisKeys().subscribe({
    next: () => {
      emitted = true;
      done(new Error('Should not emit any value'));
    },
    error: (err) => done(err),
    complete: () => {
      expect(emitted).toBe(false);
      loggerSpy.mockRestore();
      done();
    },
  });
});

/* Generated by @n1k1t/unit-generator */
it('should return zero usage when redis is not available for calculateRedisUsage', async () => {
  const mockLogger = {
    error: jest.fn(),
  };
  const loggerSpy = jest.spyOn(Logger, 'build').mockReturnValue(mockLogger as any);

  const mockRxConverter = {
    iterate: jest.fn(async function* () { }),
  };
  const rxConverterSpy = jest.spyOn(RxConverter, 'build').mockReturnValue(mockRxConverter as any);

  const mockServer = {
    databases: {
      redis: null,
    },
  };
  const service = new AnalyticsService(mockServer as any);

  const result = await service.calculateRedisUsage();
  expect(result).toEqual({ count: 0, bytes: 0 });

  loggerSpy.mockRestore();
  rxConverterSpy.mockRestore();
});

/* Generated by @n1k1t/unit-generator */
it('should return an empty observable when redis is not available for iterateRedisKeys', () => {
  const mockServer = {
    databases: {
      redis: null,
    },
  };
  const service = AnalyticsService.build(mockServer as any);
  const result = service.iterateRedisKeys();
  let emittedValues: string[] = [];
  let completed = false;

  result.subscribe({
    next: (value) => emittedValues.push(value),
    complete: () => {
      completed = true;
    },
  });

  expect(emittedValues).toEqual([]);
  expect(completed).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('should return zero usage when redis is not available for calculateRedisUsage', async () => {
  const mockServer = {
    databases: {
      redis: null,
    },
  };
  const service = AnalyticsService.build(mockServer as any);
  const result = await service.calculateRedisUsage();
  expect(result).toEqual({ count: 0, bytes: 0 });
});

/* Generated by @n1k1t/unit-generator */
it('should return an empty observable if redis is not available', async () => {
  const mockServer = { databases: { redis: null } };
  const service = new AnalyticsService(mockServer as any);

  const result = await service.iterateRedisKeys().toPromise();

  expect(result).toBeUndefined();
});
