import { Container } from './model';

// Test generated using Keploy
test('should initialize Container with correct properties', () => {
  const provided = {
    key: 'testKey',
    payload: { data: 'testData' },
    ttl: 100,
    timestamp: Date.now(),
    prefix: 'testPrefix',
    hooks: {
      onBind: jest.fn(),
      onUnbind: jest.fn(),
    },
  };
  const container = new Container(provided);
  expect(container.key).toBe('testPrefixtestKey');
  expect(container.payload).toEqual(provided.payload);
  expect(container.ttl).toBe(provided.ttl);
  expect(container.expiresAt).toBe(provided.timestamp + provided.ttl * 1000);
});

// Test generated using Keploy
test('should merge payload correctly', () => {
  const provided = {
    key: 'testKey',
    payload: { data: 'initialData' },
    ttl: 100,
    timestamp: Date.now(),
  };
  const container = new Container(provided);
  const merged = container.merge({ data: 'newData' });
  expect(merged.payload.data).toBe('newData');
});

// Test generated using Keploy
test('should assign new payload to Container', () => {
  const provided = {
    key: 'testKey',
    payload: { data: 'initialData' },
    ttl: 100,
    timestamp: Date.now(),
  };
  const container = new Container(provided);
  container.assign({ data: 'updatedData' });
  expect(container.payload.data).toBe('updatedData');
});

// Test generated using Keploy
test('should call onBind hook when binding', () => {
  const onBindMock = jest.fn();
  const provided = {
    key: 'testKey',
    payload: {},
    ttl: 100,
    timestamp: Date.now(),
    hooks: {
      onBind: onBindMock,
    },
  };
  const container = new Container(provided);
  container.bind('testLink');
  expect(onBindMock).toHaveBeenCalled();
});

// Test generated using Keploy
test('should call onUnbind hook when unbinding', () => {
  const onUnbindMock = jest.fn();
  const provided = {
    key: 'testKey',
    payload: {},
    ttl: 100,
    timestamp: Date.now(),
    hooks: {
      onUnbind: onUnbindMock,
    },
  };
  const container = new Container(provided);
  container.unbind();
  expect(onUnbindMock).toHaveBeenCalled();
});

/* Generated by @n1k1t/unit-generator */
it('merge replaces arrays when merging', () => {
  const container = Container.build({
    key: 'k',
    payload: { items: [1, 2] },
    ttl: 5,
    timestamp: 0,
  });

  container.merge({ items: [3] });

  expect(container.payload.items).toEqual([3]);
});

/* Generated by @n1k1t/unit-generator */
it('clone deep clones payload', () => {
  const container = Container.build({
    key: 'k',
    payload: { nested: { a: 1 } },
    ttl: 5,
    timestamp: 0,
  });

  const cloned = container.clone();

  expect(cloned.payload.nested).not.toBe(container.payload.nested);
});

/* Generated by @n1k1t/unit-generator */
it('toPlain returns only key prefix payload and ttl', () => {
  const container = Container.build({
    key: 'key',
    prefix: 'pre:',
    payload: { a: 1 },
    ttl: 10,
    timestamp: 0,
  });

  const plain = container.toPlain();

  expect(plain).toEqual({ key: 'pre:key', prefix: 'pre:', payload: { a: 1 }, ttl: 10 });
});
