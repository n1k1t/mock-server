import { faker } from '@faker-js/faker';
import { Router } from './router';

// Test generated using Keploy
test('should set default transports when no transports are provided', () => {
  const mockServer = {
    providers: {
      register: jest.fn(),
      default: {} // mocked default provider
    },
    transports: new Map([['default', {}]]) // mocked transports
  };

  const router = new Router(<any>mockServer);
  const pattern = 'route-pattern';
  const configuration = { provider: {} }; // mocked provider

  const result = router.register(pattern, <any>configuration);

  expect(mockServer.providers.register).toHaveBeenCalledWith(configuration.provider);
  expect(result.get(pattern)).toEqual({
    provider: configuration.provider,
    transports: { default: {} } // default transport set
  });
});

// Test generated using Keploy
test('match should yield default provider and transport for non-matching pattern', () => {
  const mockServer = {
    providers: {
      register: jest.fn(),
      default: {} // mocked default provider
    },
    transports: new Map([['transport2', {}]]) // mocked transports
  };
  const router = new Router(<any>mockServer);
  const pattern = 'route/*';
  const configuration = {
    provider: {},
    transports: ['transport1']
  };
  router.register(pattern, <any>configuration);

  const result = Array.from(router.match('transport2', 'random/path'));
  expect(result).toHaveLength(1);
  expect(result[0]).toEqual({
    provider: mockServer.providers.default,
    transport: {}
  });
});

/* Generated by @n1k1t/unit-generator */
it('should decrease router size when routes are unregistered', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });
  router.register('/pattern3', { provider: provider1, transports: ['http'] });

  router.unregister(provider1);

  expect(router.size).toBe(1);
});

/* Generated by @n1k1t/unit-generator */
it('should delete a route associated with the given provider group (pattern1)', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });
  router.register('/pattern3', { provider: provider1, transports: ['http'] });

  router.unregister(provider1);

  expect(router.has('/pattern1')).toBe(false);
});

/* Generated by @n1k1t/unit-generator */
it('should delete another route associated with the given provider group (pattern3)', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });
  router.register('/pattern3', { provider: provider1, transports: ['http'] });

  router.unregister(provider1);

  expect(router.has('/pattern3')).toBe(false);
});

/* Generated by @n1k1t/unit-generator */
it('should keep routes not associated with the given provider group', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });
  router.register('/pattern3', { provider: provider1, transports: ['http'] });

  router.unregister(provider1);

  expect(router.has('/pattern2')).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('should return the router instance after unregistering routes', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });
  router.register('/pattern3', { provider: provider1, transports: ['http'] });

  const result = router.unregister(provider1);

  expect(result).toBe(router);
});

/* Generated by @n1k1t/unit-generator */
it('should not change router size when no routes match the provider group', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');
  const provider3 = mockProvider('group3');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });

  router.unregister(provider3);

  expect(router.size).toBe(2);
});

/* Generated by @n1k1t/unit-generator */
it('should keep existing route /pattern1 when no routes match the provider group', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');
  const provider3 = mockProvider('group3');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });

  router.unregister(provider3);

  expect(router.has('/pattern1')).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('should keep existing route /pattern2 when no routes match the provider group', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');
  const provider3 = mockProvider('group3');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });

  router.unregister(provider3);

  expect(router.has('/pattern2')).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('should return the router instance when no routes match the provider group', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');
  const provider2 = mockProvider('group2');
  const provider3 = mockProvider('group3');

  router.register('/pattern1', { provider: provider1, transports: ['http'] });
  router.register('/pattern2', { provider: provider2, transports: ['http'] });

  const result = router.unregister(provider3);

  expect(result).toBe(router);
});

/* Generated by @n1k1t/unit-generator */
it('should not change router size when unregistering from an empty router', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');

  router.unregister(provider1);

  expect(router.size).toBe(0);
});

/* Generated by @n1k1t/unit-generator */
it('should return the router instance when unregistering from an empty router', () => {
  const mockProvider = (group: string): any => ({
    group,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockTransport = (type: string) => ({
    type,
    name: faker.lorem.word(),
    options: {},
    resolve: jest.fn(),
  });

  const mockMockServer = (): any => ({
    providers: {
      default: mockProvider('default'),
      register: jest.fn(),
    },
    transports: new Map([
      ['http', mockTransport('http')],
      ['ws', mockTransport('ws')],
    ]),
  });

  const server = mockMockServer();
  const router = new Router(server);

  const provider1 = mockProvider('group1');

  const result = router.unregister(provider1);

  expect(result).toBe(router);
});
