import { faker } from '@faker-js/faker';
import { RequestContextSnapshot } from '../../models';
import { HistoryStorage } from './storage';
import { History } from './model';
import config from '../../../config';

// Test generated using Keploy
test('test_registerHistory_withoutExistingHistory_createsValidHistory', () => {
  const storage = new HistoryStorage({ group: 'test-group' });
  const historyData = { snapshot: {} };
  const result = storage.register(<any>historyData);
  expect(result).toBeInstanceOf(History);
  expect(result.group).toBe('test-group');
  expect(result.snapshot).toEqual(historyData.snapshot);
});

// Test generated using Keploy
test('test_unregisterHistory_removesHistoryFromStorage', () => {
  const storage = new HistoryStorage({ group: 'test-group' });
  const historyInstance = new History(<any>{ id: '1', snapshot: {} });
  storage.register(historyInstance);
  expect(storage.size).toBe(1);
  storage.unregister(historyInstance);
  expect(storage.size).toBe(0);
});

// Test generated using Keploy
test('test_registerHistory_exceedsLimit_removesOldestEntry', () => {
  const mockConfig = { get: () => ({ limit: 2 }) };
  jest.spyOn(config, 'get').mockImplementation(<any>mockConfig.get);

  const storage = new HistoryStorage({ group: 'test-group' });
  const history1 = new History(<any>{ id: '1', snapshot: {} });
  const history2 = new History(<any>{ id: '2', snapshot: {} });
  const history3 = new History(<any>{ id: '3', snapshot: {} });

  storage.register(history1);
  storage.register(history2);
  expect(storage.size).toBe(2);
  storage.register(history3);
  expect(storage.size).toBe(2);
  expect(storage.has('1')).toBe(false); // oldest entry should be removed
});

/* Generated by @n1k1t/unit-generator */
it('should return the newly registered history item when the limit is exceeded', () => {
  const storage = new HistoryStorage({ group: faker.word.sample() });
  const history1 = History.build({
    status: 'registered',
    group: storage['configuration'].group,
    snapshot: RequestContextSnapshot.build(<any>{ transport: faker.word.sample() }),
  });
  const history2 = History.build({
    status: 'registered',
    group: storage['configuration'].group,
    snapshot: RequestContextSnapshot.build(<any>{ transport: faker.word.sample() }),
  });

  storage.register(history1);
  const registeredHistory = storage.register(history2);

  expect(registeredHistory).toBe(history2);
});

/* Generated by @n1k1t/unit-generator */
it('should keep the newly registered history item in storage when the limit is exceeded', () => {
  const storage = new HistoryStorage({ group: faker.word.sample() });
  const history1 = History.build({
    status: 'registered',
    group: storage['configuration'].group,
    snapshot: RequestContextSnapshot.build(<any>{ transport: faker.word.sample() }),
  });
  const history2 = History.build({
    status: 'registered',
    group: storage['configuration'].group,
    snapshot: RequestContextSnapshot.build(<any>{ transport: faker.word.sample() }),
  });

  storage.register(history1);
  storage.register(history2);

  expect(storage.has(history2.id)).toBeTruthy();
});

/* Generated by @n1k1t/unit-generator */
it('should include the forwarded property in the snapshot when provided during injection', () => {
  const storage = new HistoryStorage({ group: faker.word.sample() });
  const plainHistory = {
    id: faker.string.uuid(),
    group: storage['configuration'].group,
    status: 'registered',
    timestamp: faker.date.past().toISOString(),
    snapshot: {
      transport: faker.word.sample(),
      event: faker.word.sample(),
      flags: {},
      cache: {},
      state: {},
      error: undefined,
      incoming: {},
      outgoing: {},
      messages: [],
      seed: faker.number.int(),
      forwarded: {
        messages: [faker.lorem.sentence()],
        incoming: {
          dataRaw: Buffer.from(faker.lorem.word()).toString('base64'),
          headers: {},
        },
      },
    },
  };

  storage.inject([<any>plainHistory]);

  const injectedHistory = storage.get(plainHistory.id);
  expect(injectedHistory?.snapshot.forwarded).toBeDefined();
});

/* Generated by @n1k1t/unit-generator */
it('should convert forwarded incoming dataRaw to Buffer during injection', () => {
  const storage = new HistoryStorage({ group: faker.word.sample() });
  const rawData = faker.lorem.word();
  const plainHistory = {
    id: faker.string.uuid(),
    group: storage['configuration'].group,
    status: 'registered',
    timestamp: faker.date.past().toISOString(),
    snapshot: {
      transport: faker.word.sample(),
      event: faker.word.sample(),
      flags: {},
      cache: {},
      state: {},
      error: undefined,
      incoming: {},
      outgoing: {},
      messages: [],
      seed: faker.number.int(),
      forwarded: {
        messages: [],
        incoming: {
          dataRaw: Buffer.from(rawData).toString('base64'),
          headers: {},
        },
      },
    },
  };

  storage.inject([<any>plainHistory]);

  const injectedHistory = storage.get(plainHistory.id);
  expect(injectedHistory?.snapshot.forwarded?.incoming.dataRaw).toBeInstanceOf(Buffer);
});

/* Generated by @n1k1t/unit-generator */
it('should convert forwarded outgoing dataRaw to Buffer during injection', () => {
  const storage = new HistoryStorage({ group: faker.word.sample() });
  const rawData = faker.lorem.word();
  const plainHistory = {
    id: faker.string.uuid(),
    group: storage['configuration'].group,
    status: 'registered',
    timestamp: faker.date.past().toISOString(),
    snapshot: {
      transport: faker.word.sample(),
      event: faker.word.sample(),
      flags: {},
      cache: {},
      state: {},
      error: undefined,
      incoming: {},
      outgoing: {},
      messages: [],
      seed: faker.number.int(),
      forwarded: {
        messages: [],
        incoming: {
          dataRaw: undefined,
          headers: {},
        },
        outgoing: {
          dataRaw: Buffer.from(rawData).toString('base64'),
          headers: {},
        },
      },
    },
  };

  storage.inject([<any>plainHistory]);

  const injectedHistory = storage.get(plainHistory.id);
  expect(injectedHistory?.snapshot.forwarded?.outgoing?.dataRaw).toBeInstanceOf(Buffer);
});
