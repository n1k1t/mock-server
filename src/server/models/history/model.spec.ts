import { History } from './model';

class MockRequestContextSnapshot {
  public messages: any[] = [];
  public container: any = null;
  public data: any;

  public incoming = {};
  public outgoing = {};
  public cache = {};

  constructor(initialData: any = {}) {
    this.data = { ...initialData };
    if (initialData.messages) {
      this.messages = initialData.messages;
      delete this.data.messages;
    }
  }

  toPlain() {
    return { ...this.data, messages: this.messages, container: this.container?.toPlain() };
  }

  assign(payload: any) {
    Object.assign(this.data, payload);
  }

  omit(keys: string[]) {
    const newData = { ...this.data };
    keys.forEach(key => delete newData[key]);
    return newData;
  }

  clone() {
    return new MockRequestContextSnapshot(this.data);
  }
}

const mockBuildCounter = () => {
  let count = 0;
  return () => count++;
};

const mockGenUid = () => 'mock-uuid';

// Test generated using Keploy
test('test_pushMessage_withValidData_messageAddedToSnapshot', () => {
  const history = new History({ group: 'testGroup', snapshot: <any>{ incoming: {}, outgoing: {}, messages: [] } });
  const location = 'testLocation';
  const data = { key: 'value' };

  history.pushMessage(<any>location, data);

  expect(history.snapshot.messages.length).toBe(1);
  expect(history.snapshot.messages[0]).toEqual(
    expect.objectContaining({
      location: location,
      data: data
    })
  );
});

// Test generated using Keploy
test('test_switchStatus_updatesStatus', () => {
  const history = new History({ group: 'testGroup', snapshot: <any>{ incoming: {}, outgoing: {}, messages: [] } });
  history.switch('completed');
  expect(history.is('completed')).toBe(true);
});

/* Generated by @n1k1t/unit-generator */
it('should add a message to the snapshot messages', () => {
  const mockSnapshot = new MockRequestContextSnapshot({ id: 'snap-id' });
  const history = new History({
    group: 'test-group',
    snapshot: mockSnapshot as any,
    id: 'history-id',
  });
  Object.defineProperty(history, 'messagesCounter', { value: mockBuildCounter() });
  Object.defineProperty(history, 'id', { value: mockGenUid() });

  const initialMessagesCount = mockSnapshot.messages.length;
  history.pushMessage(<any>'location-a', { key: 'value' });

  expect(mockSnapshot.messages.length).toBe(initialMessagesCount + 1);
  expect(mockSnapshot.messages[0]).toMatchObject({
    location: 'location-a',
    data: { key: 'value' },
    id: 0,
  });
});

/* Generated by @n1k1t/unit-generator */
it('should mark the history when pushing a message', () => {
  const mockSnapshot = new MockRequestContextSnapshot({ id: 'snap-id' });
  const history = new History({
    group: 'test-group',
    snapshot: mockSnapshot as any,
    id: 'history-id',
    timestamp: Date.now() - 1000,
  });
  Object.defineProperty(history, 'messagesCounter', { value: mockBuildCounter() });
  Object.defineProperty(history, 'id', { value: mockGenUid() });

  const initialDuration = history.meta.metrics.duration;
  history.pushMessage(<any>'location-a', { key: 'value' });

  expect(history.meta.metrics.duration).toBeGreaterThan(initialDuration);
});

/* Generated by @n1k1t/unit-generator */
it('should update the snapshot data excluding specified keys', () => {
  const initialSnapshotData = { id: 'initial-snap', incoming: 'old-incoming', forwarded: 'old-forwarded', other: 'data' };
  const mockInitialSnapshot = new MockRequestContextSnapshot(initialSnapshotData);
  const history = new History({
    group: 'test-group',
    snapshot: mockInitialSnapshot as any,
    id: 'history-id',
  });
  Object.defineProperty(history, 'id', { value: mockGenUid() });

  const newSnapshotData = { id: 'new-snap', incoming: 'new-incoming', forwarded: 'new-forwarded', messages: [{ msg: 'new' }], another: 'field' };
  const mockNewSnapshot = new MockRequestContextSnapshot(newSnapshotData);

  history.actualize(mockNewSnapshot as any);

  expect(history.snapshot.toPlain()).toEqual({
    id: 'new-snap',
    other: 'data',
    another: 'field',
    incoming: 'old-incoming',
    forwarded: 'old-forwarded',
    messages: [],
  });
});

/* Generated by @n1k1t/unit-generator */
it('should mark the history when actualizing the snapshot', () => {
  const initialSnapshotData = { id: 'initial-snap', incoming: 'old-incoming', forwarded: 'old-forwarded', other: 'data' };
  const mockInitialSnapshot = new MockRequestContextSnapshot(initialSnapshotData);
  const history = new History({
    group: 'test-group',
    snapshot: mockInitialSnapshot as any,
    id: 'history-id',
    timestamp: Date.now() - 1000,
  });
  Object.defineProperty(history, 'id', { value: mockGenUid() });

  const newSnapshotData = { id: 'new-snap', incoming: 'new-incoming', forwarded: 'new-forwarded', messages: [{ msg: 'new' }], another: 'field' };
  const mockNewSnapshot = new MockRequestContextSnapshot(newSnapshotData);

  const initialDuration = history.meta.metrics.duration;
  history.actualize(mockNewSnapshot as any);

  expect(history.meta.metrics.duration).toBeGreaterThan(initialDuration);
});

/* Generated by @n1k1t/unit-generator */
it('should change the status of the history', () => {
  const mockSnapshot = new MockRequestContextSnapshot();
  const history = new History({
    group: 'test-group',
    snapshot: mockSnapshot as any,
    id: 'history-id',
    status: 'unregistered',
  });
  Object.defineProperty(history, 'id', { value: mockGenUid() });

  history.switch('registered');

  expect(history.status).toBe('registered');
});

/* Generated by @n1k1t/unit-generator */
it('should mark the history when switching status', () => {
  const mockSnapshot = new MockRequestContextSnapshot();
  const history = new History({
    group: 'test-group',
    snapshot: mockSnapshot as any,
    id: 'history-id',
    status: 'unregistered',
    timestamp: Date.now() - 1000,
  });
  Object.defineProperty(history, 'id', { value: mockGenUid() });

  const initialDuration = history.meta.metrics.duration;
  history.switch('registered');

  expect(history.meta.metrics.duration).toBeGreaterThan(initialDuration);
});

/* Generated by @n1k1t/unit-generator */
it('should assign id from configuration if provided', () => {
  const mockSnapshot = new MockRequestContextSnapshot();
  const expectedId = 'test-id-123';
  const history = new History({
    id: expectedId,
    group: 'test-group',
    snapshot: <any>mockSnapshot,
  });
  expect(history.id).toBe(expectedId);
});

/* Generated by @n1k1t/unit-generator */
it('should generate id if not provided in configuration', () => {
  const mockSnapshot = new MockRequestContextSnapshot();
  const history = new History({
    group: 'test-group',
    snapshot: <any>mockSnapshot,
  });
  expect(history.id).toBeDefined();
  expect(typeof history.id).toBe('string');
  expect(history.id.length).toBeGreaterThan(0);
});

/* Generated by @n1k1t/unit-generator */
it('should set status to "completed" and cache the plain representation when completing', () => {
  const mockSnapshot = new MockRequestContextSnapshot();
  const history = new History({
    group: 'test-group',
    snapshot: <any>mockSnapshot,
  });

  expect(history.status).not.toBe('completed');

  history.complete();

  expect(history.status).toBe('completed');
  const plainAfterComplete = history.toPlain();
  expect(plainAfterComplete.status).toBe('completed');

  history.group = 'new-group';
  expect(history.toPlain().group).toBe('new-group');
});
